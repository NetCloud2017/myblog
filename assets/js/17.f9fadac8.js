(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{351:function(t,n,a){"use strict";a.r(n);var e=a(8),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"git-常用命令集"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-常用命令集"}},[t._v("#")]),t._v(" git 常用命令集")]),t._v(" "),a("p",[t._v("（ git 管理的是改变的状态而不管理文件）")]),t._v(" "),a("p",[a("strong",[t._v("初始化")]),t._v("\ngit init\n创建 .gitIgnore 文件")]),t._v(" "),a("p",[a("strong",[t._v("创建")]),t._v(" "),a("strong",[t._v("vi")]),t._v(" ** 文件名**  创建文件\n**git branch dev **")]),t._v(" "),a("p",[t._v("还没有合并的分支是不能用小写 - d 来删除的  需要用大写 - D 来强制删除\ngit branch -D feature-vulcan\n**git  stash **  保存当初还没有完成的工作的分支去 创建一个分支去解决紧急任务。如bug;")]),t._v(" "),a("p",[t._v("修复后再checkout 回来。但是工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看存储的：（多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：git stash apply stash@{0}）")]),t._v(" "),a("p",[t._v("工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：\n一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\n另一种方式是用git stash pop，恢复的同时把stash内容也删了：")]),t._v(" "),a("p",[a("strong",[t._v("创建有说明的标签")]),t._v("\n还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：")]),t._v(" "),a("p",[t._v('$ git tag -a v0.1 -m "version 0.1 released" 1094adb')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\ngit tag v0.9 ff43531   对某个commit 打tag\n\n**添加/提交/推送/克隆/关联**\n")])])]),a("p",[t._v("git add (./*  本部做项目时禁止全部提交)    git add file2.txt file3.txt")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\n**git commit -m"commit modifile file " **\n\n**git push origin 分支**\n\n同时push到同一个分支也会冲突 \n')])])]),a("p",[t._v("解决 先git pull  若git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接   git branch --set-upstream-to=origin/dev dev")]),t._v(" "),a("p",[t._v("再 git pull")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('(如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to=origin/<branch-name> 本地分支名；\n\n因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。\n如果要推送某个标签到远程，使用命令**git push origin  v1.0**\n\n一次性推送所有没有推送到远程的tag   \n**git push orgin --tags **\n\n**git  clone "https......"**\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n\n')])])]),a("p",[t._v("git remote add origin git@github.com:michaelliao/learngit.git")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。不过就是省略了-u \n\n**合并**\n**git merge dev **\n通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。\n如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\n")])])]),a("p",[t._v('写法 git merge --no-ff -m "merge with no-ff" dev   合并dev 分支并提交；')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\n\n**切换 **\n\n**git checkout -b master**\n\n**git checkout -dev **\n\n\n**删除 **\n\n")])])]),a("p",[t._v('rm  文件名（这样直接删除文件会报警， 接着再git rm test.txt   再git commit -m "remove test.txt"就不会了')]),t._v(" "),a("p",[t._v("若是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：")]),t._v(" "),a("p",[t._v("$ git checkout -- test.txt\ngit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("**git tag -d v1.0 ** 本地删除标签\n\n删除远程的标签\n要先从本地删除 **git tag -d v0.9   **再从远程删除 git  push origin :refs/tags/v0.9  \n\n**还原 **\n\n命令git checkout -- readme.txt(丢弃工作区)意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n现在，看看readme.txt的文件内容\n\n用命令git reset HEAD   readme.txt （丢弃暂存区） 可以把暂存区的修改撤销掉（unstage），重新放回工作区\ngit reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。\ngit  log  查看commit  的版本信息以及 提交日记， 可以利用 提交 版本ID 回退到某个版本\n")])])]),a("p",[t._v("(可以用  git log --pretty=oneline  省略多余的信息")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(")\n直接退回上一个版本   git reset -- hard \bHEAD^    上上个版本 git reset --hard HEAD^^ \n前10个版本  git  reset  -- hard HEAD~10\n(注意 ： 如果要找回最新的版本就不要关闭当前的命令窗口，往上找 git log 输出的东西)\ngit  reset  comitID    --hard \n\nGit提供了一个命令git reflog用来记录你的每一次命令 (输出的结果里有 commit ID  )\n\n用标签来拉回某个版本\n**git  tag v1.3    **\n\n**显示/查看**\n\n**pwd   显示当前目录**\n**cd  文件路径       进入某个目录**\n**ls  --ah**   查看当前目录隐藏的文件\n**cat  文件名 . 后缀名 ****  ** 查看文件 \n\n**git log --graph**命令可以看到分支合并图\n\n**git  rebase ** \nrebase操作可以把本地未push的分叉提交历史整理成直线；\nrebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\n\ngit branch -a   可以查看到本地和远程到所有分支 （remotes 开头到都是远程分支）\n ![图片](https://images-cdn.shimo.im/4uRxAqAVLX8NwxZ7/QQ20180926_161429_2x.png!thumbnail)\n\n当本地之前的分支删除的情况下也可以用checkout 回来   git checkout -b 本地创建的分支名 origin / 远程的分支名 \n例如 ：git checkout -b [dev](https://www.baidu.com/s?wd=dev&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLmWm1nW9hn1I-m1R3nWDd0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnWmYnjTkPHfkn1n4nHckPWfd) origin/[dev](https://www.baidu.com/s?wd=dev&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLmWm1nW9hn1I-m1R3nWDd0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnWmYnjTkPHfkn1n4nHckPWfd)，\n\n查看远程库的信息 ：** git remote**   详细的 用 ： git remote -v \n**git  tag **查看所有的标签\n**git show  v0.9** 查看标签信息 \n标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。\n\n\n配置一个git last，让其**显示最后一次提交信息：**\n")])])]),a("p",[t._v("$ git config --global alias.last 'log -1'")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\n**对比**\ngit  diff \n\ngit diff 文件名    将当前工作区文件和版本区的作比较；\n用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的（readme.txt 文件）区别\n\n\n**配置**\n")])])]),a("p",[t._v("git 配置颜色git config --global color.ui true")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\n强制添加别忽略的文件\ngit add -f  忽略的文件名\n\n")])])]),a("p",[t._v("git 配置别名git config --global alias.co checkout\ngit config --global alias.ci commit\ngit config --global alias.br branch")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\nhttps协议 克隆  输入的 账号密码长期保存  \n")])])]),a("p",[t._v("git config –global credential.helper store")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\n这样就设置一个小时之后失效\n")])])]),a("p",[t._v("git config credential.helper ‘cache –timeout=3600’")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('\n使用ssh 协议clone / pull / push 项目 \n进入 .ssh 文件看看有没有公钥和私钥\ncd ~/.ssh  ----\x3e  ls\n有 id_dsa 为私钥  。id_dsa.pub 为公钥\n没有测用以下命令生成\nssh-keygen -t rsa -C "you registor gitlab emaiil"\n然后出现\n\nEnter file in which to save the key (/home/you/.ssh/id_rsa):\n\n\nEnter same passphrase again: [Type passphrase again]\n这两个都直接回车可以了\n\n最后出现\nYour public key has been saved in /home/you/.ssh/id_rsa.pub.\n\n\n查看生成的公钥\ncat ~/.ssh/id_rsa.pub\n\n然后在 gitlab 或 github 的个人设置里 将公钥放到 ssh-key 里\n\n然后检测是否成功\nssh -T git@github.com\n\n成功出现 ： Hi NetCloud2017! You\'ve successfully authenticated, but GitHub does not provide shell access.\n\n\n\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);